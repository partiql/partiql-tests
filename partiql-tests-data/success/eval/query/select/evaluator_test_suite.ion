
envs::{
  parameterTestTable:[
    {
      bar:"baz"
    },
    {
      bar:"blargh"
    }
  ],
  '':1,
  a:{
    b:{
      c:{
        d:{
          e:5,
          f:6
        }
      }
    }
  },
  b:{
    c:100
  },
  d:3.,
  e:[
    {
      books:[
        "b1",
        "b2"
      ]
    }
  ],
  f:2e0,
  i:1,
  l:[
    {
      foobar:1
    }
  ],
  numbers:[
    1,
    2.0,
    3e0,
    4,
    5.
  ],
  someList:[
    {
      a:1
    },
    {
      a:2
    },
    {
      a:3
    }
  ],
  s:"hello",
  stores:[
    {
      id:"5",
      books:[
        {
          title:"A",
          price:5.0,
          categories:[
            "sci-fi",
            "action"
          ]
        },
        {
          title:"B",
          price:2.0,
          categories:[
            "sci-fi",
            "comedy"
          ]
        },
        {
          title:"C",
          price:7.0,
          categories:[
            "action",
            "suspense"
          ]
        },
        {
          title:"D",
          price:9.0,
          categories:[
            "suspense"
          ]
        }
      ]
    },
    {
      id:"6",
      books:[
        {
          title:"A",
          price:5.0,
          categories:[
            "sci-fi",
            "action"
          ]
        },
        {
          title:"E",
          price:9.5,
          categories:[
            "fantasy",
            "comedy"
          ]
        },
        {
          title:"F",
          price:10.0,
          categories:[
            "history"
          ]
        }
      ]
    },
    {
      id:"7",
      books:[
      ]
    }
  ],
  prices:[
    5,
    2e0
  ],
  animals:[
    {
      name:"Kumo",
      type:"dog"
    },
    {
      name:"Mochi",
      type:"dog"
    },
    {
      name:"Lilikoi",
      type:"unicorn"
    }
  ],
  animal_types:[
    {
      id:"dog",
      is_magic:false
    },
    {
      id:"cat",
      is_magic:false
    },
    {
      id:"unicorn",
      is_magic:true
    }
  ],
  friends:{
    kumo:{
      type:"DOG",
      likes:{
        mochi:{
          type:"dog"
        },
        zoe:{
          type:"human"
        }
      }
    },
    mochi:{
      type:"DOG",
      likes:{
        kumo:{
          type:"dog"
        },
        brownie:{
          type:"cat"
        }
      }
    }
  }
}
basic::[
  {
    name:"literal",
    statement:"5",
    assert:{
      result:EvaluationSuccess,
      output:5
    }
  },
  {
    name:"identifier",
    statement:"i",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"identifierCaseMismatch",
    statement:"I",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"quotedIdentifier",
    statement:"\"i\"",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"lexicalScope",
    statement:"@i",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"functionCall",
    statement:"exists(select * from [1])",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"grouping",
    statement:"((i))",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"emptyListLiteral",
    statement:"[]",
    assert:{
      result:EvaluationSuccess,
      output:[
      ]
    }
  },
  {
    name:"listLiteral",
    statement:"[i, f, d]",
    assert:{
      result:EvaluationSuccess,
      output:[
        1,
        2e0,
        3.
      ]
    }
  },
  {
    name:"rowValueConstructor",
    statement:"(i, f, d)",
    assert:{
      result:EvaluationSuccess,
      output:[
        1,
        2e0,
        3.
      ]
    }
  },
  {
    name:"emptyBagLiteral",
    statement:"<<>>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"bagLiteral",
    statement:"<<i, f, d>>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2e0,
        3.
      ]
    }
  },
  {
    name:"tableValueConstructor",
    statement:"VALUES (i), (f, d)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          1
        ],
        [
          2e0,
          3.
        ]
      ]
    }
  },
  {
    name:"emptyStructLiteral",
    statement:"{}",
    assert:{
      result:EvaluationSuccess,
      output:{
      }
    }
  },
  {
    name:"structLiteral",
    statement:"{'a':i, 'b':f, 'c':d, 'd': 1}",
    assert:{
      result:EvaluationSuccess,
      output:{
        a:1,
        b:2e0,
        c:3.,
        d:1
      }
    }
  },
  {
    name:"decimalRoundUp",
    statement:"1.9999999999999999999999999999999999999999999999",
    assert:{
      result:EvaluationSuccess,
      output:2.0000000000000000000000000000000000000
    }
  },
  {
    name:"decimalRoundDown",
    statement:"1.00000000000000000000000000000000000000000001",
    assert:{
      result:EvaluationSuccess,
      output:1.0000000000000000000000000000000000000
    }
  }
]
nary::[
  {
    name:"unaryPlus",
    statement:"+i",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"unaryMinus",
    statement:"-f",
    assert:{
      result:EvaluationSuccess,
      output:-2e0
    }
  },
  {
    name:"binaryAddWith2Terms",
    statement:"1 + 1",
    assert:{
      result:EvaluationSuccess,
      output:2
    }
  },
  {
    name:"binaryAddWith3Terms",
    statement:"1 + 1 + 1",
    assert:{
      result:EvaluationSuccess,
      output:3
    }
  },
  {
    name:"addIntFloat",
    statement:"i + f",
    assert:{
      result:EvaluationSuccess,
      output:3e0
    }
  },
  {
    name:"subIntFloatDecimal",
    statement:"i - f - d",
    assert:{
      result:EvaluationSuccess,
      output:-4.
    }
  },
  {
    name:"repeatingDecimal",
    statement:"4.0000 / 3.0",
    assert:{
      result:EvaluationSuccess,
      output:1.3333333333333333333333333333333333333
    }
  },
  {
    name:"repeatingDecimalHigherPrecision",
    statement:"4.000000000000000000000000000000000000/3.0",
    assert:{
      result:EvaluationSuccess,
      output:1.3333333333333333333333333333333333333
    }
  },
  {
    name:"divDecimalInt",
    statement:"d / 2",
    assert:{
      result:EvaluationSuccess,
      output:1.5
    }
  },
  {
    name:"subtractionOutOfAllowedPrecision",
    statement:"1e100 - 1e-100",
    assert:{
      result:EvaluationSuccess,
      output:10000000000000000000000000000000000000d63
    }
  },
  {
    name:"bigDecimals",
    statement:"9223372036854775807.0 + 100.0",
    assert:{
      result:EvaluationSuccess,
      output:9223372036854775907.0
    }
  },
  {
    name:"mulFloatIntInt",
    statement:"f * 2 * 4",
    assert:{
      result:EvaluationSuccess,
      output:16e0
    }
  },
  {
    name:"modIntInt",
    statement:"3 % 2",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"equalIntFloat",
    statement:"1 = 1e0",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"equalIntFloatFalse",
    statement:"1 = 1e1",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"notEqualIntInt",
    statement:"1 != 2",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"notEqualIntFloat",
    statement:"1 != `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"notEqualIntFloatFalse",
    statement:"1 != `1e0`",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"equalListDifferentTypesTrue",
    statement:"[1, `2e0`, 'hello'] = [1.0, 2, `hello`]",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"equalListDifferentLengthsShortFirst",
    statement:"[1.0, 2] = [1.0, 2, `hello`]",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"equalListDifferentLengthsLongFirst",
    statement:"[1, `2e0`, 'hello'] = [1, `2e0`]",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"symbolEquality",
    statement:"'A' = 'A'",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"symbolCaseEquality",
    statement:"'A' = 'a'",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"moreIntFloat",
    statement:"3 > `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"moreIntFloatFalse",
    statement:"1 > `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"lessIntFloat",
    statement:"1 < `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"lessIntFloatFalse",
    statement:"3 < `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"moreEqIntFloat",
    statement:"3 >= `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"moreEqIntFloatFalse",
    statement:"1 >= `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"lessEqIntFloat",
    statement:"1 <= `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"lessEqIntFloatFalse",
    statement:"5 <= `2e0`",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  }
]
logical::[
  {
    name:"notTrue",
    statement:"not true",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"notFalse",
    statement:"not false",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"andTrueFalse",
    statement:"true and false",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"andTrueTrue",
    statement:"true and true",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"orTrueFalse",
    statement:"true or false",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"orFalseFalse",
    statement:"false or false",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  },
  {
    name:"comparisonsConjuctTrue",
    statement:"i < f and f < d",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"comparisonsDisjunctFalse",
    statement:"i < f and (f > d or i > d)",
    assert:{
      result:EvaluationSuccess,
      output:false
    }
  }
]
path::[
  {
    name:"pathSimpleDotOnly",
    statement:"b.c",
    assert:{
      result:EvaluationSuccess,
      output:100
    }
  },
  {
    name:"pathDotOnly",
    statement:"a.b.c.d.e",
    assert:{
      result:EvaluationSuccess,
      output:5
    }
  },
  {
    name:"pathDotMissingAttribute",
    statement:"a.z IS MISSING",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"pathMissingDotName",
    statement:"(MISSING).a IS MISSING",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"pathNullDotName",
    statement:"(NULL).a IS MISSING",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"pathIndexing",
    statement:"stores[0].books[2].title",
    assert:{
      result:EvaluationSuccess,
      output:"C"
    }
  },
  {
    name:"pathIndexListLiteral",
    statement:"[1, 2, 3][1]",
    assert:{
      result:EvaluationSuccess,
      output:2
    }
  },
  {
    name:"pathIndexBagLiteral",
    statement:"<<1, 2, 3>>[1]",
    assert:{
      result:EvaluationSuccess,
      output:$missing::null
    }
  },
  {
    name:"pathFieldStructLiteral",
    statement:"{'a': 1, 'b': 2, 'b': 3}.a",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"pathIndexStructLiteral",
    statement:"{'a': 1, 'b': 2, 'b': 3}[1]",
    assert:{
      result:EvaluationSuccess,
      output:2
    }
  },
  {
    name:"pathIndexStructOutOfBoundsLowLiteral",
    statement:"{'a': 1, 'b': 2, 'b': 3}[-1]",
    assert:{
      result:EvaluationSuccess,
      output:$missing::null
    }
  },
  {
    name:"pathIndexStructOutOfBoundsHighLiteral",
    statement:"{'a': 1, 'b': 2, 'b': 3}[3]",
    assert:{
      result:EvaluationSuccess,
      output:$missing::null
    }
  },
  {
    name:"pathUnpivotWildcard",
    statement:"friends.kumo.likes.*",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          type:"dog"
        },
        {
          type:"human"
        }
      ]
    }
  },
  {
    name:"pathUnpivotWildcardFieldsAfter",
    statement:"friends.kumo.likes.*.type",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "dog",
        "human"
      ]
    }
  },
  {
    name:"pathSimpleWildcard",
    statement:"someList[*].a",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        3
      ]
    }
  },
  {
    name:"selectValuePath",
    statement:"SELECT VALUE v1.books FROM e AS v1",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          "b1",
          "b2"
        ]
      ]
    }
  },
  {
    name:"pathWildcardPath",
    statement:"e[*].books",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          "b1",
          "b2"
        ]
      ]
    }
  },
  {
    name:"pathWildcard",
    statement:"stores[0].books[*].title",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "C",
        "D"
      ]
    }
  },
  {
    name:"pathDoubleWildCard",
    statement:"stores[*].books[*].title",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "C",
        "D",
        "A",
        "E",
        "F"
      ]
    }
  },
  {
    name:"pathDoubleUnpivotWildCard",
    statement:"friends.*.likes.*.type",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "dog",
        "human",
        "dog",
        "cat"
      ]
    }
  },
  {
    name:"pathWildCardOverScalar",
    statement:"s[*]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "hello"
      ]
    }
  },
  {
    name:"pathUnpivotWildCardOverScalar",
    statement:"s.*",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "hello"
      ]
    }
  },
  {
    name:"pathWildCardOverScalarMultiple",
    statement:"(100)[*][*][*]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        100
      ]
    }
  },
  {
    name:"pathUnpivotWildCardOverScalarMultiple",
    statement:"(100).*.*.*",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        100
      ]
    }
  },
  {
    name:"pathWildCardOverStructMultiple",
    statement:"a[*][*][*][*]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          b:{
            c:{
              d:{
                e:5,
                f:6
              }
            }
          }
        }
      ]
    }
  },
  {
    name:"pathUnpivotWildCardOverStructMultiple",
    statement:"a.*.*.*.*",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        5,
        6
      ]
    }
  }
]
undefined_variable_behavior::[
  {
    name:"undefinedUnqualifiedVariableWithUndefinedVariableBehaviorMissing",
    statement:"undefined_variable",
    assert:{
      result:EvaluationSuccess,
      output:$missing::null
    }
  },
  {
    name:"undefinedUnqualifiedVariableIsNullExprWithUndefinedVariableBehaviorMissing",
    statement:"undefined_variable IS NULL",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"undefinedUnqualifiedVariableIsMissingExprWithUndefinedVariableBehaviorMissing",
    statement:"undefined_variable IS MISSING",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"undefinedUnqualifiedVariableInSelectWithUndefinedVariableBehaviorMissing",
    statement:"SELECT s.a, s.undefined_variable, s.b FROM `[{a:100, b:200}]` s",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:100,
          b:200
        }
      ]
    }
  }
]
'path in from clause'::[
  {
    name:"selectFromScalarAndAtUnpivotWildCardOverScalar",
    statement:"SELECT VALUE [n, v] FROM (100).* AS v AT n",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          "_1",
          100
        ]
      ]
    }
  },
  {
    name:"selectFromListAndAtUnpivotWildCardOverScalar",
    statement:"SELECT VALUE [n, (SELECT VALUE [i, x] FROM @v AS x AT i)] FROM [100, 200].*.*.* AS v AT n",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          "_1",
          $bag::[
            [
              0,
              100
            ],
            [
              1,
              200
            ]
          ]
        ]
      ]
    }
  },
  {
    name:"selectFromBagAndAtUnpivotWildCardOverScalar",
    statement:"SELECT VALUE [n, (SELECT VALUE [i IS MISSING, i, x] FROM @v AS x AT i)] FROM <<100, 200>>.* AS v AT n",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          "_1",
          $bag::[
            [
              true,
              $missing::null,
              100
            ],
            [
              true,
              $missing::null,
              200
            ]
          ]
        ]
      ]
    }
  },
  {
    name:"selectPathUnpivotWildCardOverStructMultiple",
    statement:"SELECT name, val FROM a.*.*.*.* AS val AT name",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"e",
          val:5
        },
        {
          name:"f",
          val:6
        }
      ]
    }
  },
  {
    name:"selectStarSingleSourceHoisted",
    statement:"SELECT * FROM stores[*].books[*] AS b WHERE b.price >= 9.0",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          title:"D",
          price:9.0,
          categories:[
            "suspense"
          ]
        },
        {
          title:"E",
          price:9.5,
          categories:[
            "fantasy",
            "comedy"
          ]
        },
        {
          title:"F",
          price:10.0,
          categories:[
            "history"
          ]
        }
      ]
    }
  },
  {
    name:"ordinalAccessWithNegativeIndex",
    statement:"SELECT temp[-2] FROM <<[1,2,3,4]>> AS temp",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
        }
      ]
    }
  },
  {
    name:"ordinalAccessWithNegativeIndexAndBindings",
    statement:"SELECT temp[-2] FROM [[1,2,3,4]] AS temp",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
        }
      ]
    }
  }
]
'various types in from clause'::[
  {
    name:"rangeOverScalar",
    statement:"SELECT VALUE v FROM 1 AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1
      ]
    }
  },
  {
    name:"rangeTwiceOverScalar",
    statement:"SELECT VALUE [v1, v2] FROM 1 AS v1, @v1 AS v2",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          1,
          1
        ]
      ]
    }
  },
  {
    name:"rangeOverSexp",
    statement:"SELECT VALUE v FROM `(a b c)` AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        (
          a
          b
          c
        )
      ]
    }
  },
  {
    name:"rangeOverStruct",
    statement:"SELECT VALUE v FROM `{a:5}` AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:5
        }
      ]
    }
  },
  {
    name:"rangeOverList",
    statement:"SELECT VALUE v FROM `[1, 2, 3]` AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        3
      ]
    }
  },
  {
    name:"rangeOverListWithAt",
    statement:"SELECT VALUE i FROM `[1, 2, 3]` AT i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        0,
        1,
        2
      ]
    }
  },
  {
    name:"rangeOverListWithAsAndAt",
    statement:"SELECT VALUE [i, v] FROM `[1, 2, 3]` AS v AT i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          0,
          1
        ],
        [
          1,
          2
        ],
        [
          2,
          3
        ]
      ]
    }
  },
  {
    name:"rangeOverListConstructorWithAt",
    statement:"SELECT VALUE i FROM [1, 2, 3] AT i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        0,
        1,
        2
      ]
    }
  },
  {
    name:"rangeOverListConstructorWithAsAndAt",
    statement:"SELECT VALUE [i, v] FROM [1, 2, 3] AS v AT i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          0,
          1
        ],
        [
          1,
          2
        ],
        [
          2,
          3
        ]
      ]
    }
  },
  {
    name:"rangeOverBagWithAt",
    statement:"SELECT VALUE [i, v] FROM <<1, 2, 3>> AS v AT i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          $missing::null,
          1
        ],
        [
          $missing::null,
          2
        ],
        [
          $missing::null,
          3
        ]
      ]
    }
  },
  {
    name:"rangeOverNestedWithAt",
    statement:"SELECT VALUE [i, v] FROM (SELECT VALUE v FROM `[1, 2, 3]` AS v) AS v AT i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          $missing::null,
          1
        ],
        [
          $missing::null,
          2
        ],
        [
          $missing::null,
          3
        ]
      ]
    }
  }
]
'select list item'::[
  {
    name:"explicitAliasSelectSingleSource",
    statement:"SELECT id AS name FROM stores",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"5"
        },
        {
          name:"6"
        },
        {
          name:"7"
        }
      ]
    }
  },
  {
    name:"selectImplicitAndExplicitAliasSingleSourceHoisted",
    statement:"SELECT title AS name, price FROM stores[*].books[*] AS b WHERE b.price >= 9.0",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"D",
          price:9.0
        },
        {
          name:"E",
          price:9.5
        },
        {
          name:"F",
          price:10.0
        }
      ]
    }
  },
  {
    name:"syntheticColumnNameInSelect",
    statement:"SELECT i+1 FROM <<100>> i",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:101
        }
      ]
    }
  },
  {
    name:"properAliasFromPathInSelect",
    statement:"SELECT s.id, s.books[1].title FROM stores AS s WHERE s.id = '5'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          id:"5",
          title:"B"
        }
      ]
    }
  },
  {
    name:"selectListWithMissing",
    statement:"SELECT a.x AS x, a.y AS y FROM `[{x:5}, {y:6}]` AS a",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          x:5
        },
        {
          y:6
        }
      ]
    }
  }
]
joins::[
  {
    name:"selectCrossProduct",
    statement:"SELECT * FROM animals, animal_types",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"Kumo",
          type:"dog",
          id:"dog",
          is_magic:false
        },
        {
          name:"Kumo",
          type:"dog",
          id:"cat",
          is_magic:false
        },
        {
          name:"Kumo",
          type:"dog",
          id:"unicorn",
          is_magic:true
        },
        {
          name:"Mochi",
          type:"dog",
          id:"dog",
          is_magic:false
        },
        {
          name:"Mochi",
          type:"dog",
          id:"cat",
          is_magic:false
        },
        {
          name:"Mochi",
          type:"dog",
          id:"unicorn",
          is_magic:true
        },
        {
          name:"Lilikoi",
          type:"unicorn",
          id:"dog",
          is_magic:false
        },
        {
          name:"Lilikoi",
          type:"unicorn",
          id:"cat",
          is_magic:false
        },
        {
          name:"Lilikoi",
          type:"unicorn",
          id:"unicorn",
          is_magic:true
        }
      ]
    }
  }
]
select_where::[
  {
    name:"selectWhereStringEqualsSameCase",
    statement:"SELECT * FROM animals as a WHERE a.name = 'Kumo'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"Kumo",
          type:"dog"
        }
      ]
    }
  },
  {
    name:"selectWhereStrinEqualsDifferentCase",
    statement:"SELECT * FROM animals as a WHERE a.name = 'KUMO'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  }
]
select_join::[
  {
    name:"selectJoin",
    statement:"SELECT * FROM animals AS a, animal_types AS t WHERE a.type = t.id",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"Kumo",
          type:"dog",
          id:"dog",
          is_magic:false
        },
        {
          name:"Mochi",
          type:"dog",
          id:"dog",
          is_magic:false
        },
        {
          name:"Lilikoi",
          type:"unicorn",
          id:"unicorn",
          is_magic:true
        }
      ]
    }
  },
  {
    name:"selectCorrelatedJoin",
    statement:"SELECT s.id AS id, b.title AS title FROM stores AS s, @s.books AS b WHERE b IS NULL OR b.price > 5",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          id:"5",
          title:"C"
        },
        {
          id:"5",
          title:"D"
        },
        {
          id:"6",
          title:"E"
        },
        {
          id:"6",
          title:"F"
        }
      ]
    }
  },
  {
    name:"selectCorrelatedLeftJoin",
    statement:"SELECT s.id AS id, b.title AS title FROM stores AS s LEFT CROSS JOIN @s.books AS b WHERE b IS NULL",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          id:"7"
        }
      ]
    }
  },
  {
    name:"selectCorrelatedLeftJoinOnClause",
    statement:"SELECT s.id AS id, b.title AS title FROM stores AS s LEFT OUTER JOIN @s.books AS b ON b.price > 9",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          id:"5"
        },
        {
          id:"6",
          title:"E"
        },
        {
          id:"6",
          title:"F"
        },
        {
          id:"7"
        }
      ]
    }
  },
  {
    name:"selectJoinOnClauseScoping",
    statement:"SELECT VALUE [a, b, d] FROM [1, 3] AS a INNER JOIN [1, 2, 3] AS b ON b < d LEFT JOIN [1.1, 2.1] AS d ON b < d AND a <= d",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          1,
          1,
          1.1
        ],
        [
          1,
          1,
          2.1
        ],
        [
          1,
          2,
          2.1
        ],
        [
          3,
          1,
          null
        ],
        [
          3,
          2,
          null
        ]
      ]
    }
  },
  {
    name:"selectNonCorrelatedJoin",
    statement:"SELECT s.id AS id, v AS title FROM stores AS s, s AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          id:"5",
          title:"hello"
        },
        {
          id:"6",
          title:"hello"
        },
        {
          id:"7",
          title:"hello"
        }
      ]
    }
  },
  {
    name:"selectCorrelatedUnpivot",
    statement:"SELECT n1, n2, n3, n4, val FROM UNPIVOT a AS b AT n1, UNPIVOT @b AS c AT n2, UNPIVOT @c AS d AT n3, UNPIVOT @d AS val AT n4",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          n1:"b",
          n2:"c",
          n3:"d",
          n4:"e",
          val:5
        },
        {
          n1:"b",
          n2:"c",
          n3:"d",
          n4:"f",
          val:6
        }
      ]
    }
  },
  {
    name:"nestedSelectJoinWithUnpivot",
    statement:"SELECT col, val FROM (SELECT * FROM animals AS aa, animal_types AS tt WHERE aa.type = tt.id) AS a, UNPIVOT @a AS val AT col WHERE col != 'id'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          col:"name",
          val:"Kumo"
        },
        {
          col:"type",
          val:"dog"
        },
        {
          col:"is_magic",
          val:false
        },
        {
          col:"name",
          val:"Mochi"
        },
        {
          col:"type",
          val:"dog"
        },
        {
          col:"is_magic",
          val:false
        },
        {
          col:"name",
          val:"Lilikoi"
        },
        {
          col:"type",
          val:"unicorn"
        },
        {
          col:"is_magic",
          val:true
        }
      ]
    }
  },
  {
    name:"nestedSelectJoinLimit",
    statement:"SELECT col, val FROM (SELECT * FROM animals AS aa, animal_types AS tt WHERE aa.type = tt.id) AS a, UNPIVOT @a AS val AT col WHERE col != 'id' LIMIT 6 - 3",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          col:"name",
          val:"Kumo"
        },
        {
          col:"type",
          val:"dog"
        },
        {
          col:"is_magic",
          val:false
        }
      ]
    }
  },
  {
    name:"correlatedJoinWithShadowedAttributes",
    statement:"SELECT VALUE v FROM `[{v:5}]` AS item, @item.v AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        5
      ]
    }
  },
  {
    name:"correlatedJoinWithoutLexicalScope",
    statement:"SELECT VALUE b FROM `[{b:5}]` AS item, item.b AS b",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        5
      ]
    }
  },
  {
    name:"joinWithShadowedGlobal",
    statement:"SELECT VALUE b FROM `[{b:5}]` AS a, a.b AS b",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          c:{
            d:{
              e:5,
              f:6
            }
          }
        }
      ]
    }
  }
]
pivot::[
  {
    name:"pivotFrom",
    statement:"PIVOT a.\"type\" AT a.name FROM animals AS a",
    assert:{
      result:EvaluationSuccess,
      output:{
        Kumo:"dog",
        Mochi:"dog",
        Lilikoi:"unicorn"
      }
    }
  },
  {
    name:"pivotLiteralFieldNameFrom",
    statement:"PIVOT a.name AT 'name' FROM animals AS a",
    assert:{
      result:EvaluationSuccess,
      output:{
        name:"Kumo",
        name:"Mochi",
        name:"Lilikoi"
      }
    }
  },
  {
    name:"pivotBadFieldType",
    statement:"PIVOT a.name AT i FROM animals AS a AT i",
    assert:{
      result:EvaluationSuccess,
      output:{
      }
    }
  },
  {
    name:"pivotUnpivotWithWhereLimit",
    statement:"PIVOT val AT 'new_' || name FROM UNPIVOT `{a:1, b:2, c:3, d:4, e:5, f: 6}` AS val AT name WHERE name <> 'b' AND val <> 3 LIMIT 3",
    assert:{
      result:EvaluationSuccess,
      output:{
        new_a:1,
        new_d:4,
        new_e:5
      }
    }
  }
]
in::[
  {
    name:"inPredicate",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price IN (5, `2e0`)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "A"
      ]
    }
  },
  {
    name:"inPredicateSingleItem",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price IN (5)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "A"
      ]
    }
  },
  {
    name:"inPredicateSingleExpr",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price IN 5",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"inPredicateSingleItemListVar",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price IN (prices)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"inPredicateSingleListVar",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price IN prices",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "A"
      ]
    }
  },
  {
    name:"inPredicateSubQuerySelectValue",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price IN (SELECT VALUE p FROM prices AS p)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "A"
      ]
    }
  },
  {
    name:"notInPredicate",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price NOT IN (5, `2e0`)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "C",
        "D",
        "E",
        "F"
      ]
    }
  },
  {
    name:"notInPredicateSingleItem",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price NOT IN (5)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "B",
        "C",
        "D",
        "E",
        "F"
      ]
    }
  },
  {
    name:"notInPredicateSingleExpr",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price NOT IN 5",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "C",
        "D",
        "A",
        "E",
        "F"
      ]
    }
  },
  {
    name:"notInPredicateSingleItemListVar",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price NOT IN (prices)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "B",
        "C",
        "D",
        "A",
        "E",
        "F"
      ]
    }
  },
  {
    name:"notInPredicateSingleListVar",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price NOT IN prices",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "C",
        "D",
        "E",
        "F"
      ]
    }
  },
  {
    name:"notInPredicateSubQuerySelectValue",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE b.price NOT IN (SELECT VALUE p FROM prices AS p)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "C",
        "D",
        "E",
        "F"
      ]
    }
  },
  {
    name:"inPredicateWithTableConstructor",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE (b.title, b.price) IN (VALUES ('A', `5e0`), ('B', 3.0), ('X', 9.0))",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "A"
      ]
    }
  },
  {
    name:"notInPredicateWithTableConstructor",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE (b.title, b.price) NOT IN (VALUES ('A', `5e0`), ('B', 3.0), ('X', 9.0))",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "B",
        "C",
        "D",
        "E",
        "F"
      ]
    }
  },
  {
    name:"inPredicateWithExpressionOnRightSide",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE 'comedy' IN b.categories",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "B",
        "E"
      ]
    }
  },
  {
    name:"notInPredicateWithExpressionOnRightSide",
    statement:"SELECT VALUE b.title FROM stores[*].books[*] AS b WHERE 'comedy' NOT IN b.categories",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "A",
        "C",
        "D",
        "A",
        "F"
      ]
    }
  }
]
case::[
  {
    name:"simpleCase",
    statement:"SELECT VALUE CASE x + 1 WHEN NULL THEN 'shouldnt be null' WHEN NULL THEN 'shouldnt be missing' WHEN i THEN 'ONE' WHEN f THEN 'TWO' WHEN d THEN 'THREE' ELSE '?' END FROM << i, f, d, null, missing >> AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "TWO",
        "THREE",
        "?",
        "?",
        "?"
      ]
    }
  },
  {
    name:"simpleCaseNoElse",
    statement:"SELECT VALUE CASE x + 1 WHEN NULL THEN 'shouldnt be null' WHEN NULL THEN 'shouldnt be missing' WHEN i THEN 'ONE' WHEN f THEN 'TWO' WHEN d THEN 'THREE' END FROM << i, f, d, null, missing >> AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "TWO",
        "THREE",
        null,
        null,
        null
      ]
    }
  },
  {
    name:"searchedCase",
    statement:"SELECT VALUE CASE WHEN x + 1 < i THEN '< ONE' WHEN x + 1 = f THEN 'TWO' WHEN (x + 1 > d) AND (x + 1 < 100) THEN '>= THREE < 100' ELSE '?' END FROM << -1.0000, i, f, d, 100e0, null, missing >> AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "< ONE",
        "TWO",
        "?",
        ">= THREE < 100",
        "?",
        "?",
        "?"
      ]
    }
  },
  {
    name:"searchedCaseNoElse",
    statement:"SELECT VALUE CASE WHEN x + 1 < i THEN '< ONE' WHEN x + 1 = f THEN 'TWO' WHEN (x + 1 > d) AND (x + 1 < 100) THEN '>= THREE < 100' END FROM << -1.0000, i, f, d, 100e0, null, missing >> AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "< ONE",
        "TWO",
        null,
        ">= THREE < 100",
        null,
        null,
        null
      ]
    }
  }
]
between::[
  {
    name:"betweenPredicate",
    statement:"SELECT VALUE x FROM << -1.0000, i, f, d, 100e0 >> AS x WHERE x BETWEEN 1.000001 AND 3.0000000",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        2e0,
        3.
      ]
    }
  },
  {
    name:"notBetweenPredicate",
    statement:"SELECT VALUE x FROM << -1.0000, i, f, d, 100e0 >> AS x WHERE x NOT BETWEEN 1.000001 AND 3.0000000",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        -1.0000,
        1,
        100.
      ]
    }
  },
  {
    name:"betweenStringsPredicate",
    statement:"SELECT VALUE x FROM << 'APPLE', 'AZURE', 'B', 'XZ', 'ZOE', 'YOYO' >> AS x WHERE x BETWEEN 'B' AND 'Y'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "B",
        "XZ"
      ]
    }
  },
  {
    name:"notBetweenStringsPredicate",
    statement:"SELECT VALUE x FROM << 'APPLE', 'AZURE', 'B', 'XZ', 'Z', 'ZOE', 'YOYO' >> AS x WHERE x NOT BETWEEN 'B' AND 'Y'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "APPLE",
        "AZURE",
        "Z",
        "ZOE",
        "YOYO"
      ]
    }
  }
]
aggregates::[
  {
    name:"topLevelCountDistinct",
    statement:"COUNT(DISTINCT [1,1,1,1,2])",
    assert:{
      result:EvaluationSuccess,
      output:2
    }
  },
  {
    name:"topLevelCount",
    statement:"COUNT(numbers)",
    assert:{
      result:EvaluationSuccess,
      output:5
    }
  },
  {
    name:"topLevelAllCount",
    statement:"COUNT(ALL numbers)",
    assert:{
      result:EvaluationSuccess,
      output:5
    }
  },
  {
    name:"topLevelSum",
    statement:"SUM(numbers)",
    assert:{
      result:EvaluationSuccess,
      output:15.0
    }
  },
  {
    name:"topLevelAllSum",
    statement:"SUM(ALL numbers)",
    assert:{
      result:EvaluationSuccess,
      output:15.0
    }
  },
  {
    name:"topLevelDistinctSum",
    statement:"SUM(DISTINCT [1,1,1,1,1,1,1,2])",
    assert:{
      result:EvaluationSuccess,
      output:3
    }
  },
  {
    name:"topLevelMin",
    statement:"MIN(numbers)",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"topLevelDistinctMin",
    statement:"MIN(DISTINCT numbers)",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"topLevelAllMin",
    statement:"MIN(ALL numbers)",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"topLevelMax",
    statement:"MAX(numbers)",
    assert:{
      result:EvaluationSuccess,
      output:5.
    }
  },
  {
    name:"topLevelDistinctMax",
    statement:"MAX(DISTINCT numbers)",
    assert:{
      result:EvaluationSuccess,
      output:5.
    }
  },
  {
    name:"topLevelAllMax",
    statement:"MAX(ALL numbers)",
    assert:{
      result:EvaluationSuccess,
      output:5.
    }
  },
  {
    name:"topLevelAvg",
    statement:"AVG(numbers)",
    assert:{
      result:EvaluationSuccess,
      output:3.0
    }
  },
  {
    name:"topLevelDistinctAvg",
    statement:"AVG(DISTINCT [1,1,1,1,1,3])",
    assert:{
      result:EvaluationSuccess,
      output:2.
    }
  },
  {
    name:"topLevelAvgOnlyInt",
    statement:"AVG([2,2,2,4])",
    assert:{
      result:EvaluationSuccess,
      output:2.5
    }
  },
  {
    name:"selectValueAggregate",
    statement:"SELECT VALUE COUNT(v) + SUM(v) FROM <<numbers, numbers>> AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        20.0,
        20.0
      ]
    }
  },
  {
    name:"selectListCountStar",
    statement:"SELECT COUNT(*) AS c FROM <<numbers, numbers>> AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          c:2
        }
      ]
    }
  },
  {
    name:"selectListCountVariable",
    statement:"SELECT COUNT(v) AS c FROM <<numbers, numbers>> AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          c:2
        }
      ]
    }
  },
  {
    name:"selectListMultipleAggregates",
    statement:"SELECT COUNT(*) AS c, AVG(v * 2) + SUM(v + v) AS result FROM numbers AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          c:5,
          result:36.0
        }
      ]
    }
  },
  {
    name:"selectListMultipleAggregatesNestedQuery",
    statement:"SELECT VALUE (SELECT MAX(v2 * v2) + MIN(v2 * 2) * v1 AS result FROM numbers AS v2) FROM numbers AS v1",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        $bag::[
          {
            result:27.
          }
        ],
        $bag::[
          {
            result:29.0
          }
        ],
        $bag::[
          {
            result:31.
          }
        ],
        $bag::[
          {
            result:33.
          }
        ],
        $bag::[
          {
            result:35.
          }
        ]
      ]
    }
  },
  {
    name:"aggregateInSubqueryOfSelect",
    statement:"SELECT foo.cnt FROM (SELECT COUNT(*) AS cnt FROM [1, 2, 3]) AS foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          cnt:3
        }
      ]
    }
  },
  {
    name:"aggregateInSubqueryOfSelectValue",
    statement:"SELECT VALUE foo.cnt FROM (SELECT COUNT(*) AS cnt FROM [1, 2, 3]) AS foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        3
      ]
    }
  },
  {
    name:"aggregateWithAliasingInSubqueryOfSelectValue",
    statement:"SELECT VALUE foo.cnt FROM (SELECT COUNT(baz.bar) AS cnt FROM << { 'bar': 1 }, { 'bar': 2 } >> AS baz) AS foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        2
      ]
    }
  }
]
'projection iteration behavior unfiltered'::[
  {
    name:"undefinedUnqualifiedVariable_inSelect_withProjectionOption",
    statement:"SELECT s.a, s.undefined_variable, s.b FROM `[{a:100, b:200}]` s",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:100,
          b:200
        }
      ]
    }
  },
  {
    name:"projectionIterationBehaviorUnfiltered_select_list",
    statement:"select x.someColumn from <<{'someColumn': MISSING}>> AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          someColumn:$missing::null
        }
      ]
    }
  },
  {
    name:"projectionIterationBehaviorUnfiltered_select_star",
    statement:"select * from <<{'someColumn': MISSING}>>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          someColumn:$missing::null
        }
      ]
    }
  }
]
'ordered names'::[
  {
    name:"wildcardOrderedNames",
    statement:"SELECT * FROM <<{'a': 1, 'b': 2 }>> AS f",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1,
          b:2
        }
      ]
    }
  },
  {
    name:"aliasWildcardOrderedNames",
    statement:"SELECT f.* FROM <<{'a': 1, 'b': 2 }>> AS f",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1,
          b:2
        }
      ]
    }
  },
  {
    name:"aliasWildcardOrderedNamesSelectList",
    statement:"SELECT f.a, f.* FROM <<{'a': 1, 'b': 2 }>> AS f",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1,
          a:1,
          b:2
        }
      ]
    }
  },
  {
    name:"aliasOrderedNamesSelectList",
    statement:"SELECT f.a, f.b FROM <<{'a': 1, 'b': 2 }>> AS f",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1,
          b:2
        }
      ]
    }
  }
]
'select distinct'::[
  {
    name:"selectDistinct",
    statement:"SELECT DISTINCT t.a FROM `[{a: 1}, {a: 2}, {a: 1}]` t",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1
        },
        {
          a:2
        }
      ]
    }
  },
  {
    name:"selectDistinctWithAggregate",
    statement:"SELECT SUM(DISTINCT t.a) AS a FROM `[{a:10}, {a:1}, {a:10}, {a:3}]` t",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:14
        }
      ]
    }
  },
  {
    name:"selectDistinctSubQuery",
    statement:"SELECT * FROM (SELECT DISTINCT t.a FROM `[{a: 1}, {a: 2}, {a: 1}]` t)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1
        },
        {
          a:2
        }
      ]
    }
  },
  {
    name:"selectDistinctWithSubQuery",
    statement:"SELECT DISTINCT * FROM (SELECT t.a FROM `[{a: 1}, {a: 2}, {a: 1}]` t)",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1
        },
        {
          a:2
        }
      ]
    }
  },
  {
    name:"selectDistinctAggregationWithGroupBy",
    statement:"SELECT t.a, COUNT(DISTINCT t.b) AS c FROM `[{a:1, b:10}, {a:1, b:10}, {a:1, b:20}, {a:2, b:10}, {a:2, b:10}]` t GROUP by t.a",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1,
          c:2
        },
        {
          a:2,
          c:1
        }
      ]
    }
  },
  {
    name:"selectDistinctWithGroupBy",
    statement:"SELECT DISTINCT t.a, COUNT(t.b) AS c FROM `[{a:1, b:10}, {a:1, b:10}, {a:1, b:20}, {a:2, b:10}, {a:2, b:10}]` t GROUP by t.a",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1,
          c:3
        },
        {
          a:2,
          c:2
        }
      ]
    }
  },
  {
    name:"selectDistinctWithJoin",
    statement:"SELECT DISTINCT * FROM `[1, 1, 1, 1, 2]` t1, `[2, 2, 2, 2, 1]` t2",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:1,
          _2:2
        },
        {
          _1:1,
          _2:1
        },
        {
          _1:2,
          _2:2
        },
        {
          _1:2,
          _2:1
        }
      ]
    }
  },
  {
    name:"selectDistinctStarMixed",
    statement:"SELECT DISTINCT * FROM [ 1, 1, 2, [1], [1], [1, 2], <<>>, <<>>, MISSING, NULL, NULL, MISSING, {'a':1}, {'a':1}, {'a':2}]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:1
        },
        {
          _1:2
        },
        {
          _1:[
            1
          ]
        },
        {
          _1:[
            1,
            2
          ]
        },
        {
          _1:$bag::[
          ]
        },
        {
        },
        {
          _1:null
        },
        {
          a:1
        },
        {
          a:2
        }
      ]
    }
  },
  {
    name:"selectDistinctStarScalars",
    statement:"SELECT DISTINCT * FROM [1, 1, 2]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:1
        },
        {
          _1:2
        }
      ]
    }
  },
  {
    name:"selectDistinctStarStructs",
    statement:"SELECT DISTINCT * FROM [ {'a':1}, {'a':1}, {'a':2} ]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1
        },
        {
          a:2
        }
      ]
    }
  },
  {
    name:"selectDistinctStarUnknowns",
    statement:"SELECT DISTINCT * FROM [MISSING, NULL, NULL, MISSING]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
        },
        {
          _1:null
        }
      ]
    }
  },
  {
    name:"selectDistinctStarBags",
    statement:"SELECT DISTINCT * FROM [ <<>>, <<>>, <<1>>, <<1>>, <<1, 2>>, <<2, 1>>, <<3, 4>>]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:$bag::[
          ]
        },
        {
          _1:$bag::[
            1
          ]
        },
        {
          _1:$bag::[
            1,
            2
          ]
        },
        {
          _1:$bag::[
            3,
            4
          ]
        }
      ]
    }
  },
  {
    name:"selectDistinctStarLists",
    statement:"SELECT DISTINCT * FROM [[1], [1], [1, 2]]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:[
            1
          ]
        },
        {
          _1:[
            1,
            2
          ]
        }
      ]
    }
  },
  {
    name:"selectDistinctStarIntegers",
    statement:"SELECT DISTINCT * FROM [ 1, 1, 2 ]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:1
        },
        {
          _1:2
        }
      ]
    }
  },
  {
    name:"selectDistinctValue",
    statement:"SELECT DISTINCT VALUE t FROM [1,2,3,1,1,1,1,1] t",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        3
      ]
    }
  },
  {
    name:"selectDistinctExpressionAndWhere",
    statement:"SELECT DISTINCT (t.a + t.b) as c FROM `[{a: 1, b: 1}, {a: 2, b: 0}, {a: 0, b: 2}, {a: 2, b: 2}, {a: 0, b: 99}]` t WHERE t.a > 0",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          c:2
        },
        {
          c:4
        }
      ]
    }
  },
  {
    name:"selectDistinctExpression",
    statement:"SELECT DISTINCT (t.a || t.b) as c FROM `[{a: \"1\", b: \"1\"}, {a: \"11\", b: \"\"}, {a: \"\", b: \"11\"}, {a: \"2\", b: \"2\"}]` t",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          c:"11"
        },
        {
          c:"22"
        }
      ]
    }
  }
]
'project various container types'::[
  {
    name:"projectOfListOfList",
    statement:"SELECT * FROM [ [1,2] ] as foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:[
            1,
            2
          ]
        }
      ]
    }
  },
  {
    name:"projectOfBagOfBag",
    statement:"SELECT * FROM << <<1,2>> >> as foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:$bag::[
            1,
            2
          ]
        }
      ]
    }
  },
  {
    name:"projectOfListOfBag",
    statement:"SELECT * FROM [ <<1,2>> ] as foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:$bag::[
            1,
            2
          ]
        }
      ]
    }
  },
  {
    name:"projectOfBagOfList",
    statement:"SELECT * FROM << [1,2] >> as foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:[
            1,
            2
          ]
        }
      ]
    }
  },
  {
    name:"projectOfSexp",
    statement:"SELECT * FROM `(1 2)` as foo",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:(
            1
            2
          )
        }
      ]
    }
  },
  {
    name:"projectOfUnpivotPath",
    statement:"SELECT * FROM <<{'name': 'Marrowstone Brewing'}, {'name': 'Tesla'}>>.*",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:$bag::[
            {
              name:"Marrowstone Brewing"
            },
            {
              name:"Tesla"
            }
          ]
        }
      ]
    }
  }
]
misc::[
  {
    name:"parameters",
    statement:"SELECT ? as b1, f.bar FROM parameterTestTable f WHERE f.bar = ?",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          b1:"spam",
          bar:"baz"
        }
      ]
    }
  }
]
floatN::[
  {
    name:"castAsFloat1",
    statement:"CAST(1.234 AS FLOAT(1))",
    assert:{
      result:EvaluationSuccess,
      output:1.234e0
    }
  },
  {
    name:"canCastAsFloat1",
    statement:"CAN_CAST(1.234 AS FLOAT(1))",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  },
  {
    name:"isFloat1",
    statement:"`1.234e0` IS FLOAT(1)",
    assert:{
      result:EvaluationSuccess,
      output:true
    }
  }
]
pathUnpivotMissing::[
  {
    name:"unpivotMissing",
    statement:"SELECT * FROM UNPIVOT MISSING",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"unpivotEmptyStruct",
    statement:"SELECT * FROM UNPIVOT {}",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"unpivotStructWithMissingField",
    statement:"SELECT * FROM UNPIVOT { 'a': MISSING }",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"unpivotMissingWithAsAndAt",
    statement:"SELECT unnestIndex, unnestValue FROM UNPIVOT MISSING AS unnestValue AT unnestIndex",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"unpivotMissingCrossJoinWithAsAndAt",
    statement:"SELECT unnestIndex, unnestValue FROM MISSING, UNPIVOT MISSING AS unnestValue AT unnestIndex",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"pathUnpivotEmptyStruct1",
    statement:"{}.*.*.bar",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"pathUnpivotEmptyStruct2",
    statement:"{}.*.bar.*",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"pathUnpivotEmptyStruct3",
    statement:"{}.*.bar.*.baz",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  }
]
uncategorized::[
  {
    name:"variableShadow",
    statement:"SELECT f, d, s FROM i AS f, f AS d, @f AS s WHERE f = 1 AND d = 2e0 and s = 1",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          f:1,
          d:2e0,
          s:1
        }
      ]
    }
  },
  {
    name:"selectValueStructConstructorWithMissing",
    statement:"SELECT VALUE {'x': a.x, 'y': a.y} FROM `[{x:5}, {y:6}]` AS a",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          x:5
        },
        {
          y:6
        }
      ]
    }
  },
  {
    name:"selectIndexStruct",
    statement:"SELECT VALUE x[0] FROM (SELECT s.id FROM stores AS s) AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "5",
        "6",
        "7"
      ]
    }
  },
  {
    name:"selectStarSingleSource",
    statement:"SELECT * FROM animals",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"Kumo",
          type:"dog"
        },
        {
          name:"Mochi",
          type:"dog"
        },
        {
          name:"Lilikoi",
          type:"unicorn"
        }
      ]
    }
  },
  {
    name:"implicitAliasSelectSingleSource",
    statement:"SELECT id FROM stores",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          id:"5"
        },
        {
          id:"6"
        },
        {
          id:"7"
        }
      ]
    }
  },
  {
    name:"selectValues",
    statement:"SELECT VALUE id FROM stores",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        "5",
        "6",
        "7"
      ]
    }
  },
  {
    name:"explicitAliasSelectSingleSourceWithWhere",
    statement:"SELECT id AS name FROM stores WHERE id = '5'",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          name:"5"
        }
      ]
    }
  },
  {
    name:"undefinedQualifiedVariableWithUndefinedVariableBehaviorError",
    statement:"SELECT t.a, t.undefined_field FROM `[{a:100, b:200}]` as t",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:100
        }
      ]
    }
  },
  {
    name:"emptySymbol",
    statement:"SELECT \"\" FROM `{'': 1}`",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          '':1
        }
      ]
    }
  },
  {
    name:"emptySymbolInGlobals",
    statement:"SELECT * FROM \"\"",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:1
        }
      ]
    }
  },
  {
    name:"semicolonAtEndOfLiteral",
    statement:"1;",
    assert:{
      result:EvaluationSuccess,
      output:1
    }
  },
  {
    name:"semicolonAtEndOfExpression",
    statement:"SELECT * FROM <<1>>;",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          _1:1
        }
      ]
    }
  }
]
regression::[
  {
    name:"dateTimePartsAsVariableNames",
    statement:"SELECT VALUE [year, month, day, hour, minute, second] FROM 1968 AS year, 4 AS month, 3 as day, 12 as hour, 31 as minute, 59 as second",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          1968,
          4,
          3,
          12,
          31,
          59
        ]
      ]
    }
  },
  {
    name:"dateTimePartsAsStructFieldNames",
    statement:"SELECT VALUE [x.year, x.month, x.day, x.hour, x.minute, x.second] FROM << { 'year': 1968, 'month': 4, 'day': 3, 'hour': 12, 'minute': 31, 'second': 59 }>> AS x",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        [
          1968,
          4,
          3,
          12,
          31,
          59
        ]
      ]
    }
  }
]
bagOperators::[
  {
    name:"outerUnionDistinct",
    statement:"<< 1, 2, 2, 3, 3, 3 >> OUTER UNION << 1, 2, 3, 3 >>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        3
      ]
    }
  },
  {
    name:"outerUnionAll",
    statement:"<< 1, 2, 2, 3, 3, 3 >> OUTER UNION ALL << 1, 2, 3, 3 >>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        2,
        3,
        3,
        3
      ]
    }
  },
  {
    name:"outerIntersectDistinct",
    statement:"<< 1, 2, 2, 3, 3, 3 >> OUTER INTERSECT << 1, 2, 3, 3 >>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        3
      ]
    }
  },
  {
    name:"outerIntersectAll",
    statement:"<< 1, 2, 2, 3, 3, 3 >> OUTER INTERSECT ALL << 1, 2, 3, 3 >>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2,
        3,
        3
      ]
    }
  },
  {
    name:"outerExceptDistinct",
    statement:"<< 1, 1, 1, 2 >> OUTER EXCEPT << 1 >>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2
      ]
    }
  },
  {
    name:"outerExceptAll",
    statement:"<< 1, 1, 1, 2 >> OUTER EXCEPT ALL << 1 >>",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        1,
        2
      ]
    }
  },
  {
    name:"outerUnionCoerceScalar",
    statement:"1 OUTER UNION 2",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2
      ]
    }
  },
  {
    name:"outerUnionCoerceStruct",
    statement:"{'a': 1} OUTER UNION {'b': 2}",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        {
          a:1
        },
        {
          b:2
        }
      ]
    }
  },
  {
    name:"outerUnionCoerceNullMissing",
    statement:"NULL OUTER UNION MISSING",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
      ]
    }
  },
  {
    name:"outerUnionCoerceList",
    statement:"[ 1, 1, 1 ] OUTER UNION ALL [ 1, 2 ]",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        1,
        1,
        2
      ]
    }
  }
]
'arithmetic with mixed type'::[
  {
    name:"plus with mixed StaticType",
    statement:"SELECT VALUE v + 1 FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        2,
        3.0,
        4e0,
        5,
        6.
      ]
    }
  },
  {
    name:"minus with mixed StaticType",
    statement:"SELECT VALUE v - 1 FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        0,
        1.0,
        2e0,
        3,
        4.
      ]
    }
  },
  {
    name:"multiplication with mixed StaticType",
    statement:"SELECT VALUE v * 2 FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        2,
        4.0,
        6e0,
        8,
        10.
      ]
    }
  },
  {
    name:"division with mixed StaticType",
    statement:"SELECT VALUE v / 2 FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        0,
        1.0,
        1.5e0,
        2,
        2.5
      ]
    }
  },
  {
    name:"modulo with mixed StaticType",
    statement:"SELECT VALUE v % 2 FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        0.0,
        1e0,
        0,
        1.
      ]
    }
  },
  {
    name:"unary plus with mixed StaticType",
    statement:"SELECT VALUE +v FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        1,
        2.0,
        3e0,
        4,
        5.
      ]
    }
  },
  {
    name:"unary minus with mixed StaticType",
    statement:"SELECT VALUE -v FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        -1,
        -2.0,
        -3e0,
        -4,
        -5.
      ]
    }
  },
  {
    name:"function call with mixed StaticType",
    statement:"SELECT VALUE CAST(v/2 AS INT) FROM numbers as v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        0,
        1,
        1,
        2,
        2
      ]
    }
  },
  {
    name:"arithmetic with null/missing",
    statement:"SELECT VALUE 1 + v FROM << null, missing, 1 >> AS v",
    assert:{
      result:EvaluationSuccess,
      output:$bag::[
        null,
        null,
        2
      ]
    }
  }
]